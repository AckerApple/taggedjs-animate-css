{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAA4C;AACmB;AAExD,MAAM,GAAG,GAAG,6CAAG,CAAC,GAAG,EAAE;IAC1B,IAAI,QAAQ,GAAG,KAAK;IAEpB,gDAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC;IAEjD,OAAO,8CAAI;;MAEP,QAAQ,IAAI,CAAC,iEAAW,EAAE,CAAC,SAAS,GAAG,8CAAI;;KAE5C,CAAC;MACA,QAAQ,IAAI,CAAC,iEAAW,EAAE,CAAC,SAAS,GAAG,8CAAI;;KAE5C,CAAC;oCAC8B,GAAG,EAAE,CAAC,QAAQ,GAAG,CAAC,QAAQ,cAAc,QAAQ;GACjF;AACH,CAAC,CAAC;;;;;;;;;;;;;;;;;AClBmC;AACN;AAExB,MAAM,GAAG,GAAG,GAAG,EAAE;IACtB,OAAO,CAAC,IAAI,CAAC,6BAA6B,CAAC;IAC3C,MAAM,OAAO,GAAG,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACvD,oDAAU,CAAC,yCAAG,EAAE,OAAO,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC;AACpC,CAAC;;;;;;;;;;;;;;;;ACPM,oBAAoB,2DAA2D;AACtF;AACA,qCAAqC,mCAAmC;AACxE,yCAAyC,yDAAyD;AAClG;AACA;AACA,6BAA6B,mDAAmD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAA8E;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;AC9DkD;AACJ;AACvC,QAAQ,iCAAiC,EAAE,+DAAQ,GAAG,wCAAwC;AAC9F,QAAQ,2BAA2B,EAAE,+DAAQ,GAAG,kCAAkC;AACzF;AACO,uBAAuB,8DAA8D;AAC5F;AACA;AACA,CAAC;AACD;AACA,wBAAwB,+DAAQ,GAAG,6DAA6D;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAY;AAClC,WAAW,8CAAI;AACf,kBAAkB,MAAM,YAAY,OAAO,2BAA2B,SAAS,GAAG,UAAU;AAC5F;AACA;AACA;AACO,uBAAuB,6DAA6D;AAC3F;AACA;AACA,CAAC;AACD;AACA,wBAAwB,+DAAQ,GAAG,6DAA6D;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAY;AAClC,WAAW,8CAAI;AACf,kBAAkB,MAAM,YAAY,OAAO,2BAA2B,SAAS,GAAG,UAAU;AAC5F;AACA;AACA;;;;;;;;;;;AC1CU;AACV;;;;;;;;;;;;;;;ACDiD;AAC1C;AACP;AACA;AACA;AACA;AACA,mBAAmB,0DAAK;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVsD;AACA;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+DAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAO;AACzB;AACA,QAAQ,uDAAO;AACf,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAU,2BAA2B,+DAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAO,UAAU,uDAAO;AACpC;AACA;AACA,iBAAiB,uDAAO,UAAU,uDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAU,SAAS,0DAAU;AACtD;AACA;AACA;;;;;;;;;;;;;;;;;ACnHO;AACP;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1B+B;AACE;AACC;AACC;AACE;AACK;AACd;AACI;AACoB;AACA;AACuB;AACtC;AAC8B;AACA;AACQ;AAC1B;AACE;AAC5C;AACP,cAAc,gFAAmB,sGAAe;AAChD,iBAAiB,sFAAO;AACxB;AACA;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACgD;AACuB;AACnB;AACgB;AACI;AACxE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAmB;AACzC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,qFAAmB;AACzC;AACA,mCAAmC;AACnC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uDAAuD;AACvD;AACA;AACA;AACA,yBAAyB,iEAAS;AAClC,IAAI,iFAAoB;AACxB;AACA;AACO;AACP,QAAQ,yDAAS;AACjB;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,iCAAiC,iEAAS;AAC1C,YAAY,iFAAoB;AAChC;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2BAA2B,gFAAa;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnFqD;AAC9C;AACP;AACA;AACA,sCAAsC,8DAAc;AACpD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACTqD;AAC+B;AACC;AAC3B;AACnD;AACP;AACA;AACA,uBAAuB,+EAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wBAAwB,8DAAc;AACtC;AACA,wDAAwD,+DAAU;AAClE,yDAAyD,gFAAa;AACtE,wBAAwB,6FAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClC8D;AAC9D;AACO;AACP,IAAI,mEAAY;AAChB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7BgF;AACzE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6FAAuB;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;;;ACXyD;AACoC;AACnC;AAC1D,qCAAqC;AAC9B;AACP;AACA;AACA;AACA,2BAA2B,+DAAU;AACrC;AACA,YAAY,sEAAgB;AAC5B;AACA;AACA,eAAe,sGAAqB;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,sEAAgB;AAC/B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBiE;AACM;AAChE;AACP,MAAM,+DAAQ;AACd;AACA,MAAM,+DAAQ;AACd,IAAI,gEAAK;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,IAAI,gFAAa;AACjB;AACA;;;;;;;;;;;;;;;ACf2E;AAC3E;AACO;AACP;AACA,uBAAuB;AACvB;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,aAAa;AACb;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA,YAAY,mEAAY,8CAA8C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY,IAAI,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,YAAY,mEAAY;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;;;;;;;;;;;;;;;;AC/EA;AAC0D;AACI;AACkC;AACR;AACjF;AACP;AACA;AACA,YAAY,iGAAgB;AAC5B;AACA;AACA;AACA,mCAAmC,+DAAU;AAC7C,qDAAqD,+DAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAY;AAChC;AACA;AACA;AACA;AACA,oBAAoB,mEAAY;AAChC;AACA;AACA;AACA;AACA,IAAI,yGAAwB;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCsC;AACtC;;;;;;;;;;;;;;;;;;ACDA;AACuG;AACjD;AACD;AACuB;AACrE;AACP;AACA;AACA;AACA,2CAA2C,0DAAK;AAChD;AACA,wBAAwB,+DAAa;AACrC;AACA;AACA,QAAQ,mEAAY,OAAO,kEAAW;AACtC;AACA;AACA,QAAQ,oEAAa,OAAO,kEAAW;AACvC;AACA,IAAI,yFAAqB;AACzB;AACA;;;;;;;;;;;;;;;;ACrBA;AACiG;AACN;AACpF;AACP;AACA;AACA,0BAA0B,gGAAqB;AAC/C;AACA;AACA,IAAI,0GAAwB;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACd0E;AACtB;AAC7C,iCAAiC,+DAAc,cAAc,+DAAc;AAC3E,2CAA2C,+DAAc,YAAY,+DAAc;AAC1F;AACA,mBAAmB,+DAAc,UAAU,+DAAc;AAClD,qDAAqD,UAAU,+DAAc;AACpF;AACA,wCAAwC,MAAM,+DAAc;AAC5D;AACO;AACP;AACA;AACA,oBAAoB,iEAAS;AAC7B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,wCAAwC,+DAAc,WAAW,+DAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B,OAAO;AAClC,yBAAyB,+DAAc,8BAA8B,+DAAc;AACnF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxD0E;AACG;AACe;AACN;AACtF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAc;AAC7D;AACA,+CAA+C,kFAAa;AAC5D,0CAA0C,+DAAc,oBAAoB,+DAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+DAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kCAAkC;AACpF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,kCAAkC;AAC3H,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+DAAc,aAAa,+DAAc;AACzF;AACA,8BAA8B,+DAAc,oBAAoB,+DAAc;AAC9E;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kFAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAc,oBAAoB,+DAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sFAAiB;AAC5D;AACA;AACA;AACA,6BAA6B,2FAAgB;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,yFAAa,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvMA;AAC8D;AACY;AACY;AACtF,iBAAiB;AACV;AACP;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAc;AAC7C;AACA;AACA;AACA,oBAAoB,2FAAgB;AACpC;AACA;AACA;AACA;AACA,+BAA+B,+DAAc,YAAY,+DAAc;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY,2FAAgB,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC,+CAA+C,+DAAc;AAC7D;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA,6BAA6B,mEAAc,4BAA4B,+DAAc;AACrF,iDAAiD,+DAAc;AAC/D;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEU;AACV;;;;;;;;;;;;;;;;;;;;;;ACDkF;AAC3E;AACP;AACA,aAAa,mEAAc;AAC3B,aAAa,mEAAc;AAC3B,aAAa,mEAAc;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAU;AACvB,aAAa,+DAAU;AACvB,aAAa,+DAAU;AACvB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,+DAAU,6BAA6B,+DAAU;AACxE;AACA;AACO;AACP,6DAA6D,+DAAU;AACvE;AACO;AACP;AACA;AACO;AACP,4BAA4B,+DAAU;AACtC;AACO;AACP,8BAA8B,+DAAU;AACxC;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;AC7C+D;AACY;AAC3E;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,uEAAY;AAC/B;AACA;AACA;AACA,IAAI,uFAAkB;AACtB,+BAA+B;AAC/B;AACA;AACA;AACA,IAAI,uEAAY;AAChB;AACA;;;;;;;;;;;;;;;;;;ACpBA;AACyH;AACvC;AACpB;AAC9D,wEAAwE,aAAa,UAAU;AACxF;AACP;AACA;AACA;AACA;AACA,yBAAyB,2EAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2FAAwB;AAClD,IAAI,kIAAgC;AACpC;AACA;AACA;;;;;;;;;;;;;;;AC3DA;AAC+C;AACxC;AACP,QAAQ,wDAAQ;AAChB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACR0E;AACnE,oCAAoC,+DAAc,cAAc,+DAAc;AAC9E;AACP,yCAAyC,+DAAc;AACvD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACRO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACuF;AACtC;AACqD;AACzB;AACzB;AAC0D;AAClE;AACoE;AACjB;AACb;AACyB;AACnD;AACU;AAClE;AACO;AACP;AACA;AACA,oBAAoB,sEAAW;AAC/B;AACA;AACA;AACA,4BAA4B,wDAAa;AACzC;AACA;AACA;AACA;AACA;AACA,8BAA8B,2FAAwB;AACtD;AACA;AACA;AACA;AACA,eAAe,iGAA2B;AAC1C;AACA,qBAAqB,sEAAW;AAChC;AACA;AACA,eAAe,4FAAsB;AACrC;AACA,WAAW,uHAAqB;AAChC;AACO;AACP,QAAQ,gFAAgB;AACxB;AACA;AACA,0CAA0C;AAC1C,6BAA6B,+DAAU;AACvC;AACA;AACA,qFAAqF,wGAAa;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iCAAiC,0DAAK;AACtC;AACO;AACP;AACA,QAAQ,0DAAU;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,gGAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAY;AACxB;AACA;AACA,QAAQ,0DAAU;AAClB,eAAe,yHAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAU;AAC9C;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,+GAAmB;AACtC,WAAW,yHAAwB;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzGsE;AACgC;AAC/F;AACP;AACA,QAAQ,+GAAuB;AAC/B;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA,IAAI,mFAAoB,iHAAiH,sBAAsB;AAC/J;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfwE;AAChB;AACD;AACR;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA,MAAM,wDAAQ;AACd;AACA;AACA,MAAM,wDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qFAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAU;AACxC;AACA;AACA;AACA,WAAW,oEAAU;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5CmE;AACE;AACd;AAChD;AACP;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,IAAI,+EAAc;AAClB;AACA,QAAQ,mEAAgB;AACxB;AACA,IAAI,iFAAe;AACnB;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChBA;AACyG;AACwC;AACnE;AACzB;AAC2C;AACzF;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+CAA+C,0DAAK;AACpD,QAAQ,4DAAY,OAAO,2DAAW;AACtC;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yGAAgB;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAgB,oCAAoC,8GAAuB;AACvF;AACA;AACA;AACA,QAAQ,4DAAY,OAAO,2DAAW;AACtC;AACA;AACA,QAAQ,6DAAa,OAAO,2DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAY,OAAO,wEAAwB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA,IAAI,6DAAa,OAAO,wEAAwB;AAChD;AACA,aAAa;AACb;AACA;;;;;;;;;;;;;;;;AC7EmE;AACJ;AACxD;AACP,8CAA8C;AAC9C,8CAA8C,+DAAU;AACxD,mBAAmB,uEAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzB4C;AACgB;AACQ;AACnB;AACJ;AAC7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLmE;AAC5D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,wFAAwF;AACxF;AACA,iBAAiB;AACjB,qCAAqC;AACrC;AACA;AACA;AACO,oDAAoD,4EAAY;AACvE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO,6DAA6D,4EAAY;AAChF;AACA,yEAAyE;AACzE;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yEAAyE;AACzE;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClFuD;AACO;AACvD;AACP,wDAAwD,cAAc;AACtE,mBAAmB,6DAAkB,YAAY,sBAAsB;AACvE;AACA;AACA;AACA,gCAAgC,+DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAU;AACnC,IAAI,kDAAW,QAAQ,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClCoE;AACP;AACU;AACvE;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,uBAAuB,EAAE,iFAAiB;AACtD;AACA;AACA,QAAQ,oFAAe;AACvB;AACA;AACA,IAAI,0EAAU,0BAA0B,sBAAsB;AAC9D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClBgD;AACyB;AAClB;AACb;AACoE;AACvG;AACP,WAAW,+DAAU;AACrB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAsB;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAW;AACxB,mBAAmB,sFAAkB;AACrC,aAAa,kDAAW;AACxB,mBAAmB,oFAAgB;AACnC;AACA,YAAY,4DAAS,wBAAwB,gFAAgB;AAC7D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChF2C;AACmB;AACA;AACR;AACX;AACsB;AACE;AACX;AACiB;AACE;AACzB;AAC3C;AACP,gDAAgD,0DAAK;AACrD,IAAI,mDAAI,8BAA8B,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAQ;AAClB,wBAAwB,2EAAc,mBAAmB;AACzD,UAAU,wDAAQ;AAClB,QAAQ,yDAAK;AACb;AACA;AACA,MAAM,wDAAQ;AACd,wBAAwB,sFAAkB;AAC1C,MAAM,wDAAQ;AACd,IAAI,yDAAK;AACT;AACA;AACA;AACA,YAAY;AACZ,kBAAkB;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,6EAAa;AACpC;AACA;AACA,QAAQ,+DAAO;AACf,QAAQ,mDAAY;AACpB;AACA,gCAAgC,+DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI,+EAAc;AAClB;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA,2BAA2B,uFAAkB;AAC7C,QAAQ,+EAAc;AACtB;AACA;AACA,IAAI,qEAAW;AACf,IAAI,+EAAc;AAClB;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/EwD;AACD;AACI;AACE;AACE;AACE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAU;AAC1C,kCAAkC,yBAAyB,qBAAqB;AAChF,oBAAoB,6EAAa;AACjC;AACA,QAAQ,qEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAc;AAClB;AACA;AACA;AACA;AACA,mBAAmB,uEAAY;AAC/B;AACA,QAAQ,8DAAO,0BAA0B,uEAAY;AACrD;AACA;AACA,IAAI,gEAAS;AACb;AACA;;;;;;;;;;;;;;;;;;;ACpCgF;AACV;AACV;AACD;AACJ;AACvD;AACO;AACP;AACA;AACA;AACA;AACA,sBAAsB,yEAAa;AACnC,sCAAsC,uEAAU;AAChD;AACA,QAAQ,6FAAa;AACrB,QAAQ,mFAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,+DAAU;AACpC;AACA;AACA;AACA,YAAY,mFAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAkB;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClD+F;AACzB;AACD;AACrE;AACO;AACP;AACA;AACA,YAAY,aAAa,EAAE,0FAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4EAAe;AACpC;AACA,IAAI,kFAAY;AAChB;AACA;AACA,2BAA2B;AAC3B,IAAI,iFAAe;AACnB;AACA;;;;;;;;;;;;;;;;;;AC1BqF;AACxB;AACY;AACgB;AAClF;AACP;AACA;AACA,IAAI,kFAAY;AAChB,oBAAoB,8FAAkB;AACtC,IAAI,yEAAa;AACjB,mBAAmB,kGAAoB;AACvC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACb4E;AACI;AACT;AACb;AACmB;AAC7E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA,IAAI,mFAAkB;AACtB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,+DAAU;AAC7B,qBAAqB,kFAAc;AACnC,0BAA0B,qFAAmB;AAC7C;AACA;AACA;AACA;AACO;AACP,oBAAoB,qFAAiB;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3CmH;AACjD;AACL;AACH;AACK;AACU;AACX;AACA;AAC6B;AACpF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAU,8BAA8B,+DAAU;AAC5E;AACA,uDAAuD,+DAAU,eAAe,uEAAU;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qFAAiB;AACzD;AACA;AACA,iDAAiD,mEAAW,QAAQ,gFAAgB,GAAG,mFAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yEAAa;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA,yBAAyB,oGAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2EAAc;AAClB,IAAI,kFAAY;AAChB,kEAAkE,sBAAsB;AACxF;AACA;AACA;;;;;;;;;;;;;;;;;AC1HuD;AAC2B;AAC3E;AACP;AACA;AACA;AACA,MAAM,wDAAQ;AACd,IAAI,2FAAoB;AACxB,MAAM,wDAAQ;AACd,IAAI,yDAAK;AACT;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClBoE;AACZ;AACA;AACiB;AACzE;AACO;AACP,oBAAoB,qFAAiB;AACrC;AACA,cAAc,iEAAS;AACvB;AACA,kCAAkC,iEAAY;AAC9C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzByE;AACjB;AACP;AACM;AAChD;AACP,oBAAoB,qFAAiB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,iEAAY,cAAc;AAC/C;AACA,eAAe,oEAAa;AAC5B;AACA;AACO,sBAAsB,yDAAiB;AAC9C;;;;;;;;;;;;;;;;AChBoE;AACvB;AAC9B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gFAAa;AACjB,QAAQ,yDAAS;AACjB;AACA;AACA;AACA,YAAY,gFAAa;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtBoD;AAC7C;AACP;AACA;AACA;AACA;AACA,oBAAoB,iEAAgB;AACpC;AACA;AACA;;;;;;;;;;;;;;ACTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBoC;AACC;AACmB;AAClB;AACA;AACL;AACU;AACC;AACL;AACX;AACG;AACK;AACC;AAC0B;AACH;AAC5D;;;;;;;;;;;;;;;;;ACfuD;AACT;AACF;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,mEAAM;AAC9B,mBAAmB,mEAAM;AACzB,qBAAqB,mEAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,yDAAK;AACT,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/CyE;AAC7B;AACrC;AACP,IAAI,yDAAK;AACT,wBAAwB,qFAAiB;AACzC;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACT4C;AAC5C;AACO;AACP,IAAI,yDAAK;AACT;AACA;;;;;;;;;;;;;;;;;ACLyE;AACjB;AACZ;AAC5C;AACA,aAAa;AACb;AACO;AACP;AACA,gCAAgC,yDAAK;AACrC;AACA;AACA;AACA;AACA,gBAAgB,yDAAK;AACrB;AACA,2BAA2B,yDAAK;AAChC;AACA;AACA,uBAAuB,yDAAK;AAC5B,gCAAgC,iEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,uCAAuC;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,yDAAK;AAChB;AACA;AACA;AACA,wBAAwB,qFAAiB,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,kDAAkD,kBAAkB,EAAE,YAAY;AAClF,wBAAwB,IAAI;AAC5B;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC1F4E;AACrE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yFAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBU;AACV;;;;;;;;;;;;;;;;;ACDuD;AACJ;AACE;AAC9C;AACP;AACA;AACA;AACA;AACA,qBAAqB,4DAAa;AAClC,2BAA2B,gEAAkB;AAC7C;AACA,KAAK;AACL,cAAc;AACd;AACA;;;;;;;;;;;;;;;ACdwD;AACxD;AACO;AACP,WAAW,iEAAY;AACvB;AACA;;;;;;;;;;;ACLU;AACV;;;;;;;;;;;;;;;;;;;ACD+D;AACS;AACjE;AACP,8BAA8B,4DAAa;AAC3C,oCAAoC,gEAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC,oCAAoC,6DAAe;AACnD;AACA;AACO;AACP;AACA;AACO;AACP,6CAA6C;AAC7C,0CAA0C;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BwD;AACI;AACL;AAChD;AACP,mBAAmB,iEAAY;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,iEAAY;AAC/B;AACA;AACA,kCAAkC,+DAAU;AAC5C;AACA;AACA;AACA,+BAA+B,+DAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAa;AAChC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCwD;AACxD;AACO;AACP,mBAAmB,iEAAY;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;ACNwD;AAC2C;AACnG;AACA;AACA;AACO;AACP,mBAAmB,iEAAY;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,iEAAY;AAC/B;AACA,wBAAwB,+GAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/B4D;AACa;AACjB;AACZ;AACa;AACzD;AACO;AACP,oBAAoB,qFAAiB;AACrC;AACA,eAAe,yDAAK,WAAW,sDAAO;AACtC;AACA,eAAe,sDAAO;AACtB;AACA;AACA,wBAAwB,yDAAK;AAC7B;AACA,wBAAwB,iEAAY;AACpC,oBAAoB,iEAAY;AAChC;AACA,KAAK;AACL,uBAAuB,qFAAiB;AACxC,WAAW,yDAAK;AAChB,4BAA4B,2DAAY;AACxC,YAAY,sEAAa;AACzB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,wBAAwB,yDAAK;AAC7B,oBAAoB,iEAAY;AAChC,gBAAgB,iEAAY;AAC5B,KAAK;AACL,uBAAuB,qFAAiB;AACxC,WAAW,sDAAO;AAClB,QAAQ,sEAAa;AACrB;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCmG;AAC1B;AAC5B;AACqC;AACF;AAChF;AACO;AACP;AACA,mBAAmB,qDAAU;AAC7B,qBAAqB,0FAAoB;AACzC,gBAAgB,wFAAoB;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,+GAAmB,CAAC,qFAAiB;AACrD;AACA;AACA;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,2CAA2C,YAAY;AACvD;AACA,iDAAiD;AACjD;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DyE;AACnB;AACtD;AACO,uBAAuB,8DAAO;AACrC,SAAS,qFAAiB;AAC1B,6BAA6B;AAC7B;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;ACRmD;AACsB;AACjB;AACZ;AACa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wCAAwC,IAAI;AAC3F,qBAAqB,yDAAK;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iCAAiC,yDAAK,OAAO,qFAAiB;AAC9D,4BAA4B,yDAAK,WAAW,2DAAY;AACxD,6BAA6B,yDAAK;AAClC,4BAA4B,iEAAY;AACxC,wBAAwB,iEAAY;AACpC,aAAa;AACb;AACA;AACA,uCAAuC,qFAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAa;AACrC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gCAAgC;AAChC;;;;;;;;;;;;;;;;;;;AChHqD;AACO;AACU;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,eAAe,yEAAa;AAC5B;AACA,6CAA6C;AAC7C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC9I4D;AACrD,2BAA2B,sDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,sDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAa,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7B6C;AACtC;AACP,uBAAuB,sDAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjC8C;AACX;AACD;AACU;AACR;AACpC;;;;;;;;;;;;;;;;;;;ACL0C;AAC+B;AACE;AACpB;AACvD;AACO;AACP,oBAAoB,qFAAiB;AACrC;AACA,eAAe,sDAAK;AACpB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,+DAAU;AAC7B,qBAAqB,mFAAa;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACxC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,sDAAO;AAChC,IAAI,sDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,mBAAmB,sDAAO;AAC1B,IAAI,sDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxDO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;AC/BU;AACV;;;;;;;;;;;;;;;ACDA;AACO;AACA;AACP;;;;;;;;;;;;;;;;;ACHO;AACA;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/B0E;AAC/B;AACpC;AACP;AACA,SAAS,uDAAO;AAChB;AACA,kBAAkB;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,wBAAwB,0BAA0B;AAClD,QAAQ,uFAAgB;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBkD;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,gBAAgB,aAAa,yBAAyB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAkB;AACxC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BiE;AACK;AACvB;AACO;AACe;AAC9D;AACP;AACA;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,2DAAW;AAClC;AACA;AACA;AACA,yBAAyB,mEAAU;AACnC;AACA,YAAY,kFAAc;AAC1B,YAAY,8EAAY;AACxB,sBAAsB;AACtB;AACA;AACA,QAAQ,kFAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kFAAc;AACrC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,cAAc;AACd;AACO;AACP;AACA;AACA;AACA,IAAI,kFAAc;AAClB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CgD;AACE;AACP;AACpC;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB,2DAAU;AAC3B,iBAAiB,2DAAU;AAC3B,iBAAiB,2DAAU;AAC3B;AACA,iBAAiB,2DAAU;AAC3B,iBAAiB,2DAAU;AAC3B,iBAAiB,2DAAU;AAC3B;AACA;AACA;AACA,QAAQ,uDAAO;AACf;AACA;AACA,WAAW,4DAAS;AACpB;AACA;;;;;;;;;;;;;;;;;;AC3BgE;AACV;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAO;AACjC;AACA;AACA;AACO;AACP;AACA,QAAQ;AACR,QAAQ;AACR;AACA,mCAAmC;AACnC;AACA,8BAA8B,6EAAY;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCuF;AAChF;AACP;AACA,oBAAoB,8EAAc;AAClC;AACA,WAAW,oFAAoB;AAC/B;AACA;;;;;;;;;;;;;;;;;;;ACPkD;AACA;AACA;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAc;AAC1B,YAAY,+DAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DA;AACiH;AACd;AACjC;AACR;AAC1D;AACA;AACO;AACP,qBAAqB,uEAAY;AACjC;AACA,+BAA+B,+EAAgB;AAC/C;AACA;AACA;AACA,oBAAoB,6HAA0B;AAC9C,gBAAgB,+GAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1BA;AACkD;AACkB;AACO;AACI;AACD;AAC9E;AACO;AACP;AACA;AACA,sBAAsB,iFAAiB;AACvC;AACA,mBAAmB,2DAAU;AAC7B,qBAAqB,oFAAiB;AACtC,0BAA0B,0DAAmB;AAC7C,gBAAgB,kEAA2B;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,uFAAsB;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;ACjDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRiD;AAC1C;AACP,WAAW,yDAAY;AACvB;AACA;;;;;;;;;;;;;;;;;;;;;ACJ0D;AACkC;AAC5B;AACL;AAC6B;AAC5B;AAC5D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAAa;AACxC;AACA,eAAe,4EAAW;AAC1B;AACA;AACA;AACO;AACP,6CAA6C,mEAAW,QAAQ,4EAAgB,GAAG,+EAAmB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wGAAiB;AAC1C;AACA,0CAA0C,uEAAS;AACnD;AACA;AACA;;;;;;;;;;;;;;;;;ACrCkD;AACmB;AACgC;AAC9F;AACP;AACA,mBAAmB,2DAAU;AAC7B,qBAAqB,8EAAc;AACnC,0BAA0B,iFAAmB;AAC7C,gBAAgB,yFAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBwE;AAC3B;AACtC;AACP;AACA;AACA;AACA,8DAA8D,sDAAK;AACnE,QAAQ,mEAAY,OAAO,kEAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACdgD;AACyD;AAC7B;AACjB;AACT;AAClD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,wFAAqB;AAC/C;AACA;AACA;AACA;AACA,aAAa,mEAAW;AACxB,sBAAsB;AACtB,aAAa,mEAAW;AACxB,mBAAmB,gFAAgB;AACnC,aAAa,mEAAW;AACxB,mBAAmB,kFAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAU;AACrC,iCAAiC;AACjC,kCAAkC;AAClC;AACA,wCAAwC;AACxC,yCAAyC;AACzC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,2DAAU;AACvC,eAAe,4DAAS,iBAAiB,4EAAgB;AACzD;AACA;AACA,iCAAiC,2DAAU;AAC3C,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnF2C;AACmB;AACZ;AAClD;AACO;AACP;AACA;AACA;AACA,yBAAyB,2EAAc;AACvC;AACA;AACO;AACP;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACO;AACP;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA,YAAY,uDAAO,UAAU,uDAAO;AACpC;AACA;AACA;AACA,wBAAwB;AACxB;AACA,8BAA8B,2DAAU,mCAAmC,2DAAU;AACrF,sBAAsB;AACtB;AACA,8BAA8B,2DAAU;AACxC,4CAA4C,2DAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA,oBAAoB;AACpB;AACA,kBAAkB;AAClB;AACO;AACA;AACP;AACA;AACA,2BAA2B,2DAAU,oCAAoC,2DAAU;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClEoD;AACO;AACW;AACF;AACpE;AACO;AACP,sBAAsB,iFAAY;AAClC,sBAAsB,mFAAkB,CAAC,mEAAW;AACpD;AACA;AACA;AACA;AACA;AACA,WAAW,iEAAS;AACpB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfiE;AAClC;AACoB;AACjB;AACW;AACL;AACT;AACL;AACW;AACmB;AACP;AACE;AACD;AACf;AACH;AACkB;AACE;AACqC;AAC3B;AACH;AACb;AAC8B;AAC5E;;;;;;;;;;;;;;ACtBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACb8D;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,kCAAkC,2DAAU;AAC5C;AACA;AACA;AACA,aAAa,2DAAU;AACvB,sCAAsC,2DAAU;AAChD,8BAA8B;AAC9B;AACA;AACA;AACA,aAAa,2DAAU;AACvB;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2DAAU,oCAAoC,2DAAU;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChFuF;AAChF;AACP;AACA,uBAAuB,8EAAc;AACrC,IAAI,oFAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACV2E;AACT;AACE;AACF;AAClE;AACO;AACP;AACA,eAAe,mFAAY,EAAE;AAC7B;AACA,oBAAoB,iFAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAe;AACvB,qCAAqC;AACrC;AACA,QAAQ,8EAAe;AACvB;AACA;AACA,QAAQ,+EAAiB;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BA;AACkD;AACkB;AACO;AACI;AACU;AACzF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,wFAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,sGAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAmB;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,iFAAiB;AACvC,mBAAmB,2DAAU;AAC7B,qBAAqB,oFAAiB;AACtC,0BAA0B,0DAAmB;AAC7C,gBAAgB,kEAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;AClF2E;AACpE;AACP;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uFAAe;AAC1C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BwF;AACJ;AACf;AACD;AACT;AACR;AACC;AAC7C;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,2DAAW;AACnB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAgB;AAClC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,QAAQ,uDAAO;AACf;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA,kCAAkC,2DAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2BAA2B,iFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yDAAY;AAChB;AACA;AACO;AACP,8BAA8B,2DAAU;AACxC;AACO;AACP;AACA,qBAAqB,+EAAY;AACjC;AACA,uBAAuB,mFAAgB;AACvC;AACA;AACA;AACA;AACA,IAAI,6FAAsB;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;;ACnJmD;AACc;AACwB;AAC3B;AACvD;AACP;AACA,gCAAgC,2DAAU;AAC1C;AACA;AACA;AACA,aAAa,mEAAW;AACxB;AACA;AACA;AACA;AACA,aAAa,mEAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6EAAe,IAAI,+EAAmB;AACjD;AACA;AACA,WAAW,6EAAe,QAAQ,4EAAgB;AAClD;AACA;;;;;;;;;;;;;;;;AChCkE;AACyB;AAC3F;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAQ;AACtB;AACA;AACA;AACA,cAAc,+DAAQ;AACtB,YAAY,gEAAK;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA,MAAM,+DAAQ;AACd;AACA;AACA,MAAM,+DAAQ;AACd,IAAI,gEAAK;AACT;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,YAAY,+EAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAa,OAAO,mEAAY;AAC5C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAa,OAAO,mEAAY;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAa,OAAO,mEAAY;AACpC;AACA;;;;;;;;;;;;;;AC/FO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;ACDiE;AACH;AACQ;AAC7B;AACW;AACF;AACa;AACsC;AAC3B;AACJ;AACtE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,kFAAc;AACtB;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA,0BAA0B,kDAAW;AACrC,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAS,gBAAgB,uEAAY;AACzC;AACA,+CAA+C,2DAAU;AACzD;AACA,aAAa,8DAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sFAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iFAAmB;AACjD,oBAAoB,yFAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAY;AAC/B;AACA;AACA,IAAI,mFAAkB;AACtB;AACA;AACA;;;;;;;;;;;;;;ACrFA;AACO;AACP;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;;;;;;;;;;;;;;;;AClBmD;AACiB;AAC7D;AACP,mEAAmE,2DAAU;AAC7E;AACA;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjB6E;AACJ;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kFAAc;AACtB;AACA;AACA;AACA;AACA,IAAI,oEAAa,OAAO,mEAAY;AACpC;AACA;;;;;;;;;;;;;;;;;ACvCA;AACuG;AACG;AAC5D;AAC9C;AACO;AACP;AACA,4CAA4C,sDAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAa,OAAO,kEAAW;AACvC;AACA,IAAI,mHAAqB;AACzB;AACA,QAAQ,mEAAY,OAAO,kEAAW;AACtC;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtB6E;AACD;AACrE;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAa,OAAO,mEAAY;AACxC;AACA;AACA;AACA,0BAA0B,qFAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrBoE;AACpE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,IAAI,iFAAiB;AACrB;AACA;;;;;;;;;;;;;;ACbO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLkF;AACrB;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAAa;AACtC;AACA;AACA;AACA,IAAI,2FAAe;AACnB;AACA;;;;;;;;;;;;;;;;;;;;;ACnBkE;AACF;AACI;AACc;AAClF;;;;;;;;;;;;;;;ACJwF;AACjF;AACP;AACA;AACA;AACA,6BAA6B,qGAA2B;AACxD;AACA;;;;;;;;;;;;;;;;;ACPuE;AACY;AACrB;AACvD;AACP,sBAAsB,mFAAkB,CAAC,mEAAW;AACpD;AACA,oBAAoB,4FAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBiH;AACvD;AACgB;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,uFAAgB;AACpC;AACA,mBAAmB,uEAAY;AAC/B;AACA,eAAe,uFAAoB;AACnC;AACA,oBAAoB,4FAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,iFAAU;AACrB;AACA;;;;;;;;;;;;;;;;;;;;ACnCgG;AACjB;AAC5B;AACQ;AACE;AACtD;AACP;AACA;AACA,uBAAuB,yEAAa;AACpC;AACA;AACA,oDAAoD,2DAAU,qBAAqB,uEAAc;AACjG;AACA;AACA;AACA,YAAY,UAAU,EAAE,wFAAiB;AACzC;AACA,IAAI,sFAAuB;AAC3B;AACA;AACO;AACP;AACA;AACA,uBAAuB,yEAAa;AACpC;AACA;AACA,oDAAoD,2DAAU,qBAAqB,uEAAc;AACjG;AACA;AACA;AACA,YAAY,UAAU,EAAE,wFAAiB;AACzC;AACA,IAAI,oFAAqB;AACzB;AACA;AACA;;;;;;;;;;;;;;;ACnC8E;AACvE;AACP;AACA;AACA,qBAAqB,uFAAe;AACpC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACRiF;AACsB;AACpB;AAC5E;AACP;AACA;AACA,oBAAoB,4FAAqB;AACzC;AACA,mBAAmB,0FAAkB;AACrC;AACA;AACA;AACA,gBAAgB,mEAAY,OAAO,kEAAW;AAC9C;AACA;AACA,gBAAgB,oEAAa,OAAO,kEAAW;AAC/C;AACA;AACA;AACA;AACA,gBAAgB,mEAAY,OAAO,kEAAW;AAC9C;AACA;AACA,gBAAgB,oEAAa,OAAO,kEAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BgE;AAC4B;AACd;AACvE;AACP,wBAAwB,yEAAa;AACrC;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,IAAI,iEAAU;AACd;AACA;AACO;AACP;AACA,2BAA2B,uFAAe;AAC1C;AACA,wBAAwB,yEAAa;AACrC,uCAAuC,sEAAe;AACtD;AACA;AACA,aAAa;AACb,IAAI,oEAAa;AACjB;AACA;;;;;;;;;;;;;;;;;ACzB8D;AACvD;AACP,WAAW,2EAAc;AACzB;AACO;AACP;AACA,yBAAyB,2EAAc;AACvC;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,2EAAc;AAClB;AACA;;;;;;;;;;;;;;;;;ACfA;AAC4E;AACR;AACoB;AACjF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,+BAA+B,iFAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qGAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yFAAqB;AAC7B;AACA;AACA,wBAAwB,qGAA2B;AACnD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjEuH;AAC7D;AACnD;AACP;AACA;AACA,IAAI,uEAAY;AAChB;AACA,8BAA8B,uGAA4B;AAC1D;AACA;AACA,0BAA0B,sGAA2B;AACrD;AACA;AACA;;;;;;;;;;;;;;;;ACbwE;AACE;AACnE;AACP;AACA,eAAe,uFAAoB;AACnC;AACA;AACA;AACA,KAAK;AACL,WAAW,iFAAU;AACrB;AACA;;;;;;;;;;;;;;;;;ACXiF;AACN;AACpE;AACP;AACA,IAAI,0FAAkB;AACtB;AACA;AACA;AACO;AACP,sBAAsB,mEAAY;AAClC,mBAAmB,0FAAkB;AACrC;AACA;AACA,YAAY,mEAAY,2BAA2B,kEAAW;AAC9D;AACA;AACA,YAAY,mEAAY,2BAA2B,kEAAW;AAC9D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrBuD;AACW;AACA;AACgB;AACoB;AACpC;AACF;AACI;AACS;AACtE;AACP,YAAY,6BAA6B,EAAE,yFAAqB;AAChE;AACA;AACA;AACA,0BAA0B,yEAAe;AACzC;AACA;AACO;AACP;AACA;AACA,sBAAsB,+GAAmB;AACzC;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA,YAAY,+FAAwB,gDAAgD,sBAAsB;AAC1G,6BAA6B,uEAAY;AACzC,gBAAgB,gEAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,WAAW,+EAAgB;AAC3B;AACA;;;;;;;;;;;;;;;;;;;ACxDiE;AACd;AACL;AAC4B;AACF;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAAe;AACvB,qBAAqB;AACrB;AACA,QAAQ,uDAAO;AACf,eAAe,qFAAmB;AAClC;AACA,WAAW,uFAAoB;AAC/B;AACA;;;;;;;;;;;;;;;;;;AC9BwG;AACtB;AACrB;AAC7D;AACO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI,+FAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAa;AACjC,IAAI,iHAA0B;AAC9B;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzBmD;AACE;AACK;AACI;AACiB;AAC/E;AACO;AACP;AACA,mBAAmB,8DAAc;AACjC;AACA;AACA,YAAY,uEAAY;AACxB;AACA,QAAQ,4FAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA,YAAY,2EAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxC4E;AACrE;AACP,sCAAsC,YAAY;AAClD;AACA;AACA,sBAAsB,yFAAqB;AAC3C;AACA;AACA;AACA;;;;;;;;;;;;;;;ACT4E;AACrE;AACP;AACA;AACA;AACA;AACA,uBAAuB,yFAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClBqD;AACS;AAChB;AACS;AACoB;AACG;AACvE;AACP;AACA;AACA;AACA,0BAA0B,iDAAU;AACpC;AACA;AACA,QAAQ,2EAAc;AACtB;AACA;AACA,QAAQ,uDAAO;AACf,QAAQ,oEAAe;AACvB,+BAA+B,uFAAc;AAC7C;AACA;AACA,8BAA8B,iDAAU;AACxC,sCAAsC;AACtC;AACA;AACA;AACA,QAAQ,wFAAsB;AAC9B;AACA;AACA;;;;;;;;;;;;;;;;AC7B4D;AAC8B;AACnF;AACP;AACA,8CAA8C,iDAAU;AACxD;AACA,QAAQ,sGAAyB;AACjC,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,4DAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,cAAc;AACd;AACA;;;;;;;;;;;;;;;;ACtCyG;AACtC;AAC5D;AACP;AACA;AACA;AACA;AACA,0BAA0B,wFAAqB;AAC/C,gBAAgB,0FAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI,+EAAe;AACnB;AACA;;;;;;;;;;;;;;;;AChByF;AACvB;AAClE;AACA;AACA;AACA;AACA;AACA,IAAI,8EAAwB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B,EAAE,gEAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAiB;AACrB;AACO;AACP;AACA;AACA;AACA,gBAAgB,uDAAgB;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChC6D;AAC8B;AACb;AACvE;AACP;AACA;AACA;AACA;AACA,0BAA0B,uFAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAAa;AACrC;AACA;AACA,uCAAuC,sEAAe;AACtD;AACA;AACA,qDAAqD,oCAAoC;AACzF,aAAa;AACb,IAAI,oEAAa;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAa;AACxC,QAAQ,oEAAa;AACrB;AACA;AACA,IAAI,oEAAa,OAAO,mEAAY;AACpC;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrCwC;AACG;AACT;AACgC;AACY;AAC9E;;;;;;;;;;;;;;;;;;;ACLmG;AAC1B;AAC5B;AACiC;AACE;AAChF;AACO;AACP;AACA,mBAAmB,qDAAU;AAC7B,qBAAqB,sFAAgB;AACrC,gBAAgB,wFAAoB;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,+GAAmB,CAAC,qFAAiB;AACrD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACiD;AAC0B;AAChC;AACgB;AACJ;AACoC;AACC;AACc;AAC1G;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,uFAAkB;AAC5C,8BAA8B,+DAAU;AACxC,gCAAgC,oGAAuB;AACvD;AACA,6BAA6B,uEAAU;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,mDAAI;AACnB,iBAAiB,yDAAY;AAC7B,qBAAqB,+DAAU;AAC/B,+BAA+B;AAC/B,IAAI,mDAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAU;AAChD,wCAAwC,mGAAqB;AAC7D,mCAAmC,6FAA2B;AAC9D;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,oBAAoB,yDAAY;AAChC,gBAAgB;AAChB;AACA,mCAAmC,+DAAU;AAC7C,qCAAqC,oGAAuB;AAC5D,0CAA0C,qFAAmB;AAC7D,gCAAgC,6FAA2B;AAC3D,KAAK;AACL,CAAC;AACD;;;;;;;;;;;;;;;;;AC9F2C;AACqB;AACA;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAO;AACf,eAAe,6EAAc;AAC7B;AACA,WAAW,6EAAe;AAC1B;AACA;;;;;;SChBA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;ACNoC;AAEpC,kDAAG,EAAE","sources":["webpack:///./src/app.tag.ts","webpack:///./src/run.function.ts","webpack:///../main/dist/js/createFx.function.js","webpack:///../main/dist/js/index.js","webpack:///../../taggedjs/main/dist/js/TagJsEvent.type.js","webpack:///../../taggedjs/main/dist/js/castTextValue.function.js","webpack:///../../taggedjs/main/dist/js/deepFunctions.js","webpack:///../../taggedjs/main/dist/js/errors.js","webpack:///../../taggedjs/main/dist/js/index.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/addSupportEventListener.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/bindSubjectCallback.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/getSupportWithState.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/getUpTags.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/howToSetInputValue.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/isSpecialAttribute.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/processAttributeCallback.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/processNameValueAttribute.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/renderTagArray.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/specialAttribute.js","webpack:///../../taggedjs/main/dist/js/interpolations/attributes/updateAttribute.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/index.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/attachDynamicDom.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/domProcessContextItem.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/htmlInterpolationToDomMeta.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/parseHTML.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/replacePlaceholders.function.js","webpack:///../../taggedjs/main/dist/js/interpolations/optimizers/types.js","webpack:///../../taggedjs/main/dist/js/isInstance.js","webpack:///../../taggedjs/main/dist/js/render/afterRender.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/createDynamicAttribute.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/getTagJsVar.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/getTagVarIndex.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/isNoDisplayValue.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/processAttribute.function.js","webpack:///../../taggedjs/main/dist/js/render/attributes/processUpdateAttrContext.function.js","webpack:///../../taggedjs/main/dist/js/render/buildBeforeElement.function.js","webpack:///../../taggedjs/main/dist/js/render/destroySupport.function.js","webpack:///../../taggedjs/main/dist/js/render/dom/attachDomElements.function.js","webpack:///../../taggedjs/main/dist/js/render/executeWrap.function.js","webpack:///../../taggedjs/main/dist/js/render/index.js","webpack:///../../taggedjs/main/dist/js/render/paint.function.js","webpack:///../../taggedjs/main/dist/js/render/registerNewTagElement.function.js","webpack:///../../taggedjs/main/dist/js/render/renderExistingTag.function.js","webpack:///../../taggedjs/main/dist/js/render/renderSupport.function.js","webpack:///../../taggedjs/main/dist/js/render/renderTagElement.function.js","webpack:///../../taggedjs/main/dist/js/render/renderTagOnly.function.js","webpack:///../../taggedjs/main/dist/js/render/renderWithSupport.function.js","webpack:///../../taggedjs/main/dist/js/render/softDestroySupport.function.js","webpack:///../../taggedjs/main/dist/js/render/update/processRenderOnceInit.function.js","webpack:///../../taggedjs/main/dist/js/render/update/processTag.function.js","webpack:///../../taggedjs/main/dist/js/render/update/updateExistingTagComponent.function.js","webpack:///../../taggedjs/main/dist/js/render/update/updateSupportBy.function.js","webpack:///../../taggedjs/main/dist/js/state/callback.function.js","webpack:///../../taggedjs/main/dist/js/state/callbackMaker.function.js","webpack:///../../taggedjs/main/dist/js/state/callbackStateUpdate.function.js","webpack:///../../taggedjs/main/dist/js/state/getStateValue.function.js","webpack:///../../taggedjs/main/dist/js/state/handleProviderChanges.function.js","webpack:///../../taggedjs/main/dist/js/state/index.js","webpack:///../../taggedjs/main/dist/js/state/letProp.function.js","webpack:///../../taggedjs/main/dist/js/state/onDestroy.js","webpack:///../../taggedjs/main/dist/js/state/onInit.js","webpack:///../../taggedjs/main/dist/js/state/providers.js","webpack:///../../taggedjs/main/dist/js/state/providersChangeCheck.function.js","webpack:///../../taggedjs/main/dist/js/state/setUse.function.js","webpack:///../../taggedjs/main/dist/js/state/setUseMemory.object.js","webpack:///../../taggedjs/main/dist/js/state/state.function.js","webpack:///../../taggedjs/main/dist/js/state/state.types.js","webpack:///../../taggedjs/main/dist/js/state/state.utils.js","webpack:///../../taggedjs/main/dist/js/state/stateHandlers.js","webpack:///../../taggedjs/main/dist/js/state/states.function.js","webpack:///../../taggedjs/main/dist/js/state/states.utils.js","webpack:///../../taggedjs/main/dist/js/state/subject.function.js","webpack:///../../taggedjs/main/dist/js/state/subscribeWith.function.js","webpack:///../../taggedjs/main/dist/js/state/syncStates.function.js","webpack:///../../taggedjs/main/dist/js/state/tagClosed$.subject.js","webpack:///../../taggedjs/main/dist/js/state/watch.function.js","webpack:///../../taggedjs/main/dist/js/subject/Subject.class.js","webpack:///../../taggedjs/main/dist/js/subject/ValueSubject.js","webpack:///../../taggedjs/main/dist/js/subject/combineLatest.function.js","webpack:///../../taggedjs/main/dist/js/subject/index.js","webpack:///../../taggedjs/main/dist/js/subject/signal.function.js","webpack:///../../taggedjs/main/dist/js/subject/subject.utils.js","webpack:///../../taggedjs/main/dist/js/subject/will.functions.js","webpack:///../../taggedjs/main/dist/js/tag/Context.types.js","webpack:///../../taggedjs/main/dist/js/tag/DomTag.type.js","webpack:///../../taggedjs/main/dist/js/tag/ValueTypes.enum.js","webpack:///../../taggedjs/main/dist/js/tag/checkDestroyPrevious.function.js","webpack:///../../taggedjs/main/dist/js/tag/checkStateMismatch.function.js","webpack:///../../taggedjs/main/dist/js/tag/checkTagValueChange.function.js","webpack:///../../taggedjs/main/dist/js/tag/cloneValueArray.function.js","webpack:///../../taggedjs/main/dist/js/tag/createHtmlSupport.function.js","webpack:///../../taggedjs/main/dist/js/tag/createSupport.function.js","webpack:///../../taggedjs/main/dist/js/tag/destroyContext.function.js","webpack:///../../taggedjs/main/dist/js/tag/domMetaCollector.js","webpack:///../../taggedjs/main/dist/js/tag/getDomTag.function.js","webpack:///../../taggedjs/main/dist/js/tag/getStringsId.function.js","webpack:///../../taggedjs/main/dist/js/tag/getSupportInCycle.function.js","webpack:///../../taggedjs/main/dist/js/tag/getTagWrap.function.js","webpack:///../../taggedjs/main/dist/js/tag/getTemplaterResult.function.js","webpack:///../../taggedjs/main/dist/js/tag/guaranteeInsertBefore.function.js","webpack:///../../taggedjs/main/dist/js/tag/hasPropChanges.function.js","webpack:///../../taggedjs/main/dist/js/tag/hasSupportChanged.function.js","webpack:///../../taggedjs/main/dist/js/tag/html.js","webpack:///../../taggedjs/main/dist/js/tag/index.js","webpack:///../../taggedjs/main/dist/js/tag/isLastRunMatched.function.js","webpack:///../../taggedjs/main/dist/js/tag/isLikeTags.function.js","webpack:///../../taggedjs/main/dist/js/tag/loadNewBaseSupport.function.js","webpack:///../../taggedjs/main/dist/js/tag/output.function.js","webpack:///../../taggedjs/main/dist/js/tag/processOuterDomTagInit.function.js","webpack:///../../taggedjs/main/dist/js/tag/processUpdateContext.function.js","webpack:///../../taggedjs/main/dist/js/tag/props/alterProp.function.js","webpack:///../../taggedjs/main/dist/js/tag/props/clonePropsBy.function.js","webpack:///../../taggedjs/main/dist/js/tag/smartRemoveKids.function.js","webpack:///../../taggedjs/main/dist/js/tag/tag.types.js","webpack:///../../taggedjs/main/dist/js/tag/tag.utils.js","webpack:///../../taggedjs/main/dist/js/tag/tagElement.js","webpack:///../../taggedjs/main/dist/js/tag/tagRunner.js","webpack:///../../taggedjs/main/dist/js/tag/update/checkSubContext.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/compareArrayItems.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/createAndProcessContextItem.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/deleteSubContext.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/forceUpdateExistingValue.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/getNewGlobal.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/handleStillTag.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/index.js","webpack:///../../taggedjs/main/dist/js/tag/update/onFirstSubContext.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/oneRenderToSupport.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processDomTagInit.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processFirstSubjectComponent.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processFirstSubjectValue.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processNewSubjectTag.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processRegularValue.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processSubscribe.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processTagArray.js","webpack:///../../taggedjs/main/dist/js/tag/update/processTagComponentInit.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processTagInit.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/processTagResult.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/setupSubscribe.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/syncPriorPropFunction.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/tagValueUpdateHandler.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/tryUpdateToTag.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/updateExistingArray.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/updateExistingObject.function.js","webpack:///../../taggedjs/main/dist/js/tag/update/updateToDiffValue.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/checkSimpleValueChange.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/getArrayTagJsVar.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/getInnerHTML.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/getSimpleTagVar.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/index.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/subscribe.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/tag.function.js","webpack:///../../taggedjs/main/dist/js/tagJsVars/valueToTagJsVar.function.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/index.ts"],"sourcesContent":["import { html, states, tag } from \"taggedjs\"\nimport { animateWrap, animateLoop } from \"taggedjs-animate-css\"\n\nexport const app = tag(() => {\n  let showHide = false\n\n  states(get => [{ showHide }] = get({ showHide }))\n\n  return html`\n    hello world\n    ${showHide && (animateWrap().innerHTML = html`\n      Hello animated world 33\n    `)}\n    ${showHide && (animateLoop().innerHTML = html`\n      Hello animated world 33\n    `)}\n    <button type=\"button\" onclick=${() => showHide = !showHide}>show/hide ${showHide}</button>\n  `\n})\n","import { tagElement } from \"taggedjs\"\nimport { app } from \"./app.tag\"\n\nexport const run = () => {// app.ts\n  console.info('attaching app to element...')\n  const element = document.getElementsByTagName('app')[0]\n  tagElement(app, element, {test:1})\n}\n","export function createFx({ fxIn, fxOut, staggerBy = 300, outPositionAbsolute = true, }) {\n    return {\n        in: (input) => animateInit({ fxName: fxIn, staggerBy, ...input }),\n        out: (input) => animateDestroy({ fxName: fxOut, staggerBy, outPositionAbsolute, ...input }),\n    };\n}\nconst animateInit = async ({ target, stagger, staggerBy, fxName = 'fadeInDown' }) => {\n    target.style.opacity = '0';\n    if (stagger) {\n        await wait(stagger * staggerBy);\n    }\n    target.style.opacity = '1';\n    target.classList.add('animate__animated', 'animate__' + fxName);\n};\nconst animateDestroy = async ({ target, stagger, outPositionAbsolute = true, fxName = 'fadeOutUp', staggerBy }) => {\n    if (!outPositionAbsolute) {\n        console.log('outPositionAbsolute', outPositionAbsolute);\n    }\n    if (outPositionAbsolute) {\n        captureElementPosition(target);\n    }\n    if (stagger) {\n        await wait(stagger * staggerBy);\n    }\n    return new Promise(function (res) {\n        // Create a one-time event listener\n        function handleAnimationEnd(event) {\n            // Optional: make sure the event is from the target element\n            if (event.target !== target)\n                return;\n            // Clean up\n            target.classList.remove('animate__animated', 'animate__' + fxName);\n            target.removeEventListener('animationend', handleAnimationEnd);\n            res(undefined);\n        }\n        target.classList.add('animate__animated', 'animate__' + fxName);\n        target.addEventListener('animationend', handleAnimationEnd);\n    });\n};\n// absolute\nexport function captureElementPosition(element) {\n    element.style.zIndex = element.style.zIndex || 1;\n    const toTop = element.offsetTop + 'px';\n    const toLeft = element.offsetLeft + 'px';\n    const toWidth = (element.clientWidth + (element.offsetWidth - element.clientWidth) + 1) + 'px';\n    const toHeight = (element.clientHeight + (element.offsetHeight - element.clientHeight) + 1) + 'px';\n    const fix = () => {\n        element.style.top = toTop;\n        element.style.left = toLeft;\n        element.style.width = toWidth;\n        element.style.height = toHeight;\n        element.style.position = 'absolute';\n    };\n    // element.style.position = 'fixed'\n    // allow other elements that are being removed to have a moment to figure out where they currently sit\n    setTimeout(fix, 0);\n}\nfunction wait(time) {\n    return new Promise((res) => {\n        setTimeout(res, time);\n    });\n}\n//# sourceMappingURL=createFx.function.js.map","import { createFx } from \"./createFx.function.js\";\nimport { getInnerHTML, html } from \"taggedjs\";\nexport const { in: fadeInDown, out: fadeOutUp } = createFx({ fxIn: 'fadeInDown', fxOut: 'fadeOutUp' });\nexport const { in: fadeIn, out: fadeOut } = createFx({ fxIn: 'fadeIn', fxOut: 'fadeOut' });\n/** Use on html elements to have them animated in and out */\nexport function animateWrap({ fxIn, fxOut, duration = '.2s', outPositionAbsolute = false, } = {\n    duration: '.2s',\n    outPositionAbsolute: false,\n}) {\n    if (!fxIn || !fxOut) {\n        const created = createFx({ fxIn: 'fadeInDown', fxOut: 'fadeOutUp', outPositionAbsolute });\n        if (!fxIn) {\n            fxIn = created.in;\n        }\n        if (!fxOut) {\n            fxOut = created.out;\n        }\n    }\n    const innerHTML = getInnerHTML();\n    return html `\n    <div oninit=${fxIn} ondestroy=${fxOut} style.--animate-duration=${duration}>${innerHTML}</div>\n  `.acceptInnerHTML(innerHTML);\n}\n/** Use on html elements, within a loop, to have them animated in and out */\nexport function animateLoop({ fxIn, fxOut, duration = '.2s', outPositionAbsolute = true, } = {\n    duration: '.2s',\n    outPositionAbsolute: true,\n}) {\n    if (!fxIn || !fxOut) {\n        const created = createFx({ fxIn: 'fadeInDown', fxOut: 'fadeOutUp', outPositionAbsolute });\n        if (!fxIn) {\n            fxIn = created.in;\n        }\n        if (!fxOut) {\n            fxOut = created.out;\n        }\n    }\n    const innerHTML = getInnerHTML();\n    return html `\n    <div oninit=${fxIn} ondestroy=${fxOut} style.--animate-duration=${duration}>${innerHTML}</div>\n  `.acceptInnerHTML(innerHTML);\n}\n//# sourceMappingURL=index.js.map","export {};\n//# sourceMappingURL=TagJsEvent.type.js.map","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n//# sourceMappingURL=castTextValue.function.js.map","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n//# sourceMappingURL=deepFunctions.js.map","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n//# sourceMappingURL=errors.js.map","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n//# sourceMappingURL=index.js.map","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n//# sourceMappingURL=addSupportEventListener.function.js.map","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    const component = getSupportWithState(support);\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    const states = component.states; // ?.[0]\n    subjectFunction.states = states;\n    // subjectFunction.states = [...states]\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, states, bindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.subject;\n    const global = subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete global.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n//# sourceMappingURL=bindSubjectCallback.function.js.map","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.subject.global.newest || component;\n}\n//# sourceMappingURL=getSupportWithState.function.js.map","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n//# sourceMappingURL=getUpTags.function.js.map","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n//# sourceMappingURL=howToSetInputValue.function.js.map","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'oninit';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n//# sourceMappingURL=isSpecialAttribute.function.js.map","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n//# sourceMappingURL=processAttributeCallback.function.js.map","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    // contextItem.attrName = attrName\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n//# sourceMappingURL=processNameValueAttribute.function.js.map","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n//# sourceMappingURL=renderTagArray.function.js.map","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        case 'init': { // aka oninit\n            const stagger = counts.added++;\n            // run delayed after elements placed down\n            paintAfters.push([paintSpecialAttribute, [element, stagger, value]]);\n            return;\n        }\n        case 'destroy': { // aka ondestroy\n            const stagger = counts.removed++;\n            const global = support.subject.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\nfunction paintSpecialAttribute(element, stagger, value) {\n    const event = {\n        target: element,\n        stagger,\n    };\n    value(event); // call init/oninit\n}\n//# sourceMappingURL=specialAttribute.js.map","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n//# sourceMappingURL=updateAttribute.function.js.map","export * from './optimizers/types.js';\n//# sourceMappingURL=index.js.map","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n//# sourceMappingURL=attachDynamicDom.function.js.map","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { tagValueUpdateHandler } from \"../../tag/update/tagValueUpdateHandler.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    contextItem.handler = tagValueUpdateHandler;\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = value;\n}\n//# sourceMappingURL=domProcessContextItem.function.js.map","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\n/*\nfunction sanitizePlaceholders(fragments: string[]) {\n  return fragments.map(santizeFragment)\n}\n\nfunction santizeFragment(fragment: string) {\n  return fragment.replace(\n    fragReplacer,\n    (match, index) => safeVar + index)\n}\n*/\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n//# sourceMappingURL=htmlInterpolationToDomMeta.function.js.map","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n//# sourceMappingURL=parseHTML.function.js.map","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n//# sourceMappingURL=replacePlaceholders.function.js.map","export {};\n//# sourceMappingURL=types.js.map","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n//# sourceMappingURL=isInstance.js.map","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n//# sourceMappingURL=afterRender.function.js.map","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n            };\n            contextItem.handler = function arrayItemHanlder(value, newSupport, contextItem, newValues) {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial) {\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n    };\n    context.push(contextItem);\n    contextItem.handler = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n//# sourceMappingURL=createDynamicAttribute.function.js.map","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n//# sourceMappingURL=getTagJsVar.function.js.map","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n//# sourceMappingURL=getTagVarIndex.function.js.map","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n//# sourceMappingURL=isNoDisplayValue.function.js.map","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        // how to process value updates\n        contextItem.handler = processUpdateAttrContext;\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, context, howToSet, support, counts, values);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, context, howToSet, support, counts, isSpecial);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n//# sourceMappingURL=processAttribute.function.js.map","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n//# sourceMappingURL=processUpdateAttrContext.function.js.map","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.subject;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n//# sourceMappingURL=buildBeforeElement.function.js.map","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.subject;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.context;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n//# sourceMappingURL=destroySupport.function.js.map","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function blankHandler() {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, howToSetFirstInputValue, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    if (!insertBefore?.parentNode) {\n        console.log('insertBefore, string', { insertBefore, string });\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n//# sourceMappingURL=attachDomElements.function.js.map","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    config.support = useSupport;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n//# sourceMappingURL=executeWrap.function.js.map","export * from './renderTagOnly.function.js';\nexport { renderSupport } from './renderSupport.function.js';\nexport { renderWithSupport } from './renderWithSupport.function.js';\nexport * from './buildBeforeElement.function.js';\nexport * from './destroySupport.function.js';\n//# sourceMappingURL=index.js.map","import { blankHandler } from \"./dom/attachDomElements.function.js\";\nexport let paintCommands = [];\nexport let paintContent = [];\nexport let setContent = [];\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n    paintReset();\n    for (const content of paintAfters) {\n        content[0](...content[1]);\n    }\n    paintAfters = [];\n    console.log('------ painting cycle completed ----');\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n    setContent = [];\n}\nexport function paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    if (!relative.parentNode) {\n        console.log('relative', { relative, textElm, callback });\n    }\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n//# sourceMappingURL=paint.function.js.map","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug(' Building element into tag...', { element, app });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug(' Element Tag DOM built ');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n//# sourceMappingURL=registerNewTagElement.function.js.map","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject, { added: 0, removed: 0 });\n    return support;\n}\n//# sourceMappingURL=renderExistingTag.function.js.map","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(ownerSupport, support);\n        return result;\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    delete global.locked;\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n//# sourceMappingURL=renderSupport.function.js.map","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { setUseMemory } from '../index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        setUseMemory.stateConfig, oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n//# sourceMappingURL=renderTagElement.function.js.map","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    const config = setUseMemory.stateConfig;\n    if (prevState) {\n        reState(newSupport, prevSupport, setUseMemory.stateConfig, prevState);\n        return;\n    }\n    initState(newSupport, config);\n}\n//# sourceMappingURL=renderTagOnly.function.js.map","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n//# sourceMappingURL=renderWithSupport.function.js.map","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.subject.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n//# sourceMappingURL=softDestroySupport.function.js.map","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem, ownerSupport);\n    const result = processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    return result;\n}\n//# sourceMappingURL=processRenderOnceInit.function.js.map","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem, // could be tag via result.tag\ncounts) {\n    const global = contextItem.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    const ph = contextItem.placeholder;\n    if (!ph?.parentNode) {\n        console.log('no parent before processTag', { ph, contextItem });\n    }\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n//# sourceMappingURL=processTag.function.js.map","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = global.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.subject;\n    const global = subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const global = oldSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n//# sourceMappingURL=updateExistingTagComponent.function.js.map","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n//# sourceMappingURL=updateSupportBy.function.js.map","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n//# sourceMappingURL=callback.function.js.map","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n//# sourceMappingURL=callbackMaker.function.js.map","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.subject.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    //syncStatesArray(oldStates, newestSupport.states)\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            // syncStatesArray(oldStates, newestSupport.states)\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n//# sourceMappingURL=callbackStateUpdate.function.js.map","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n//# sourceMappingURL=getStateValue.function.js.map","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n//# sourceMappingURL=handleProviderChanges.function.js.map","export * from './watch.function.js';\nexport * from './setUse.function.js';\nexport { setUseMemory } from './setUseMemory.object.js';\nexport * from './subject.function.js';\nexport * from './letProp.function.js';\nexport * from './state.types.js';\nexport { providers } from './providers.js';\nexport * from './callbackMaker.function.js';\nexport * from './callback.function.js';\nexport * from './onInit.js';\nexport * from './onDestroy.js';\nexport * from './state.function.js';\nexport * from './states.function.js';\nexport { subscribe } from '../tagJsVars/subscribe.function.js';\nexport { subscribeWith } from './subscribeWith.function.js';\n//# sourceMappingURL=index.js.map","import { signal } from '../subject/signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n//# sourceMappingURL=letProp.function.js.map","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n//# sourceMappingURL=onDestroy.js.map","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n//# sourceMappingURL=onInit.js.map","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.subject.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.subject.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n//# sourceMappingURL=providers.js.map","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n//# sourceMappingURL=providersChangeCheck.function.js.map","export {};\n//# sourceMappingURL=setUse.function.js.map","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n//# sourceMappingURL=setUseMemory.object.js.map","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n//# sourceMappingURL=state.function.js.map","export {};\n//# sourceMappingURL=state.types.js.map","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.support = support;\n}\nexport function reState(newSupport, prevSupport, config, prevState) {\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n//# sourceMappingURL=state.utils.js.map","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n//# sourceMappingURL=stateHandlers.js.map","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n//# sourceMappingURL=states.function.js.map","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n//# sourceMappingURL=states.utils.js.map","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n//# sourceMappingURL=subject.function.js.map","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            return -1;\n        },\n        Observable,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n//# sourceMappingURL=subscribeWith.function.js.map","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n//# sourceMappingURL=syncStates.function.js.map","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n//# sourceMappingURL=tagClosed$.subject.js.map","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.subject.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n//# sourceMappingURL=watch.function.js.map","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n//# sourceMappingURL=Subject.class.js.map","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n//# sourceMappingURL=ValueSubject.js.map","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n//# sourceMappingURL=combineLatest.function.js.map","export { signal } from './signal.function.js';\nexport * from './Subject.class.js';\nexport * from './ValueSubject.js';\nexport * from './combineLatest.function.js';\nexport * from './will.functions.js';\n//# sourceMappingURL=index.js.map","import { state } from '../state/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                // Notify all subscribers\n                subscribers.forEach(callback => callback(newValue));\n            }\n        },\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n//# sourceMappingURL=signal.function.js.map","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n//# sourceMappingURL=subject.utils.js.map","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n//# sourceMappingURL=will.functions.js.map","export {};\n//# sourceMappingURL=Context.types.js.map","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n//# sourceMappingURL=DomTag.type.js.map","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    // subject: 'subject',\n    // tagJsSubject: 'tagJsSubject',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n//# sourceMappingURL=ValueTypes.enum.js.map","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n//# sourceMappingURL=checkDestroyPrevious.function.js.map","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n//# sourceMappingURL=checkStateMismatch.function.js.map","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    if (!global) {\n        return 663; // its not a tag this time\n    }\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport, counts);\n        return -1;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n//# sourceMappingURL=checkTagValueChange.function.js.map","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n//# sourceMappingURL=cloneValueArray.function.js.map","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n//# sourceMappingURL=createHtmlSupport.function.js.map","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n//# sourceMappingURL=createSupport.function.js.map","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.context;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n//# sourceMappingURL=destroyContext.function.js.map","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n//# sourceMappingURL=domMetaCollector.js.map","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n//# sourceMappingURL=getDomTag.function.js.map","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n//# sourceMappingURL=getStringsId.function.js.map","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n//# sourceMappingURL=getSupportInCycle.function.js.map","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n//# sourceMappingURL=getTagWrap.function.js.map","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n//# sourceMappingURL=getTemplaterResult.function.js.map","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n//# sourceMappingURL=guaranteeInsertBefore.function.js.map","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n//# sourceMappingURL=hasPropChanges.function.js.map","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n//# sourceMappingURL=hasSupportChanged.function.js.map","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n//# sourceMappingURL=html.js.map","export { getNewGlobal } from './update/getNewGlobal.function.js';\nexport * from './tag.types.js';\nexport { getDomMeta } from './domMetaCollector.js';\nexport * from './update/index.js';\nexport * from '../tagJsVars/tag.function.js';\nexport * from './getDomTag.function.js';\nexport * from './tag.utils.js';\nexport * from './html.js';\nexport * from './ValueTypes.enum.js';\nexport * from './update/oneRenderToSupport.function.js';\nexport * from './getTemplaterResult.function.js';\nexport * from './checkDestroyPrevious.function.js';\nexport * from './checkTagValueChange.function.js';\nexport * from './Context.types.js';\nexport * from './tagElement.js';\nexport { variablePrefix } from './DomTag.type.js';\nexport { paint } from '../render/paint.function.js';\nexport { processFirstSubjectValue } from './update/processFirstSubjectValue.function.js';\nexport { hasPropChanges } from './hasPropChanges.function.js';\nexport { PropWatches } from '../tagJsVars/tag.function.js';\nexport { output } from './output.function.js';\nexport { guaranteeInsertBefore } from './guaranteeInsertBefore.function.js';\n//# sourceMappingURL=index.js.map","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isLastRunMatched.function.js.map","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=isLikeTags.function.js.map","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n//# sourceMappingURL=loadNewBaseSupport.function.js.map","import { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/alterProp.function.js\";\n/** Used to call a function that belongs to a calling tag */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        const ownerGlobal = ownerSupport.subject.global;\n        const newestOwner = ownerGlobal.newest;\n        // sync the new states to the old before the old does any processing\n        syncStatesArray(newestOwner.states, ownerSupport.states);\n        const c = callback(...args); // call the latest callback\n        // sync the old states to the new\n        syncStatesArray(ownerSupport.states, newestOwner.states);\n        // now render the owner\n        const newestOwnerOwner = newestOwner.ownerSupport;\n        safeRenderSupport(newestOwner, newestOwnerOwner.subject.global.newest);\n        return c;\n    };\n}\n//# sourceMappingURL=output.function.js.map","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    console.log('processOuterDomTagInit******', {\n        appendTo, insertBefore,\n        parentNode: insertBefore?.parentNode,\n        contextItem,\n        placeholder: contextItem.placeholder,\n        placeholderParentNode: contextItem.placeholder?.parentNode,\n    });\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    console.log('set');\n    contextItem.handler = function outDomTagHanlder(value, newSupport, contextItem2, _values, counts) {\n        console.log('xxxxx', {\n            contextItem,\n            contextItem2,\n            equal: contextItem === contextItem2,\n        });\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = function outerCheckValueChange(newValue, contextItem, counts) {\n        return checkOuterTagValueChange(newValue, contextItem, counts);\n    };\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n//# sourceMappingURL=processOuterDomTagInit.function.js.map","import { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support, counts);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const handler = contextItem.handler;\n    handler(value, ownerSupport, contextItem, values, counts);\n    contextItem.value = value;\n    contextItem.tagJsVar = valueToTagJsVar(value);\n}\n//# sourceMappingURL=processUpdateContext.function.js.map","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingReadyTag } from '../../render/renderExistingTag.function.js';\nimport { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        if (!global || global.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n//# sourceMappingURL=alterProp.function.js.map","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n//# sourceMappingURL=clonePropsBy.function.js.map","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, paintCommands, painting, paintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.context;\n    // already set\n    // global.deleted = true\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nconst promises = [];\nfunction destroyCall(destroy) {\n    const maybePromise = destroy();\n    const isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        promises.push(maybePromise);\n    }\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    promises.length = 0;\n    destroys.forEach(destroyCall);\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.context, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.context, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintCommands.push([paintRemover, [elm]]);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    htmlDomMeta.forEach(destroyClone);\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        paintCommands.push([paintRemover, [marker]]);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    paintCommands.push([paintRemover, [dom]]);\n}\n//# sourceMappingURL=smartRemoveKids.function.js.map","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n//# sourceMappingURL=tag.types.js.map","export const tags = [];\n//# sourceMappingURL=tag.utils.js.map","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nif (document) {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.subject.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar: {\n            tagJsType: 'templater',\n            checkValueChange: checkTagValueChange,\n            delete: destroySupportByContextItem,\n            processInit: function appDoNothing() {\n                console.debug('do nothing app function');\n            }\n        }\n    };\n    const global = getNewGlobal(subject);\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n//# sourceMappingURL=tagElement.js.map","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n//# sourceMappingURL=tagRunner.js.map","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, _values, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== ValueTypes.subscribe) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valueHandler(subscription.lastValue);\n    return -1;\n}\n//# sourceMappingURL=checkSubContext.function.js.map","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    paintCommands.push([paintRemover, [element]]);\n}\n//# sourceMappingURL=compareArrayItems.function.js.map","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n//# sourceMappingURL=createAndProcessContextItem.function.js.map","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        paintCommands.push([paintRemover, [appendMarker]]);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    contextItem.handler = tagValueUpdateHandler;\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const tagJsVar = subContextItem.tagJsVar;\n    tagJsVar.delete(subContextItem, ownerSupport);\n    return 76;\n}\n//# sourceMappingURL=deleteSubContext.function.js.map","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n//# sourceMappingURL=forceUpdateExistingValue.function.js.map","export function getNewGlobal(contextItem) {\n    ;\n    contextItem.renderCount = contextItem.renderCount || 0;\n    return contextItem.global = {};\n}\n//# sourceMappingURL=getNewGlobal.function.js.map","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n//# sourceMappingURL=handleStillTag.function.js.map","export { deleteSubContext } from './deleteSubContext.function.js';\nexport { checkSubContext } from './checkSubContext.function.js';\nexport { onFirstSubContext } from './onFirstSubContext.function.js';\nexport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n//# sourceMappingURL=index.js.map","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n//# sourceMappingURL=onFirstSubContext.function.js.map","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n//# sourceMappingURL=oneRenderToSupport.function.js.map","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    console.log('processDomTagInit - 1', {\n        appendTo,\n        insertBefore,\n        parentNode: insertBefore?.parentNode,\n        placeholder: contextItem.placeholder,\n        placeholderParentNode: contextItem.placeholder?.parentNode,\n        contextItem,\n    });\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    console.log('processDomTagInit - 2', {\n        appendTo,\n        insertBefore,\n        parentNode: insertBefore?.parentNode,\n        placeholder: contextItem.placeholder,\n        placeholderParentNode: contextItem.placeholder?.parentNode,\n        contextItem,\n    });\n    return processTag(ownerSupport, contextItem, counts);\n}\n//# sourceMappingURL=processDomTagInit.function.js.map","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { renderWithSupport } from '../../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n//# sourceMappingURL=processFirstSubjectComponent.function.js.map","import { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nexport function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tagJsVar = valueToTagJsVar(value);\n    contextItem.tagJsVar = tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n//# sourceMappingURL=processFirstSubjectValue.function.js.map","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n//# sourceMappingURL=processNewSubjectTag.function.js.map","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n//# sourceMappingURL=processRegularValue.function.js.map","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observable = value.Observable;\n    const subscription = setupSubscribe(observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        subscription.valueHandler((observable.value || value.withDefault));\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe(value, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n//# sourceMappingURL=processSubscribe.function.js.map","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, undefined, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n//# sourceMappingURL=processTagArray.js.map","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n//# sourceMappingURL=processTagComponentInit.function.js.map","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    console.log('process a new tag', {\n        insertBefore, appendTo,\n    });\n    return processTag(ownerSupport, contextItem, counts);\n}\n//# sourceMappingURL=processTagInit.function.js.map","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    const ph = contextItem.placeholder;\n    buildBeforeElement(support, counts, undefined, // element for append child\n    ph);\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, [paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, [paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n//# sourceMappingURL=processTagResult.function.js.map","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observable, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observable, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    contextItem.handler = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observable, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onValue = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            forceUpdateExistingValue(subContext.contextItem, value, ownerSupport, { added: 0, removed: 0 });\n            if (!syncRun && !setUseMemory.stateConfig.support) {\n                paint();\n            }\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value) {\n        subContext.lastValue = value;\n        const newComponent = component.subject.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            value = subContext.callback(value);\n        }\n        onValue(value);\n    }\n    let syncRun = true;\n    const subContext = {\n        valueHandler,\n        callback,\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    subContext.subscription = observable.subscribe(valueHandler);\n    syncRun = false;\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscription.unsubscribe();\n    return deleteSubContext(contextItem, ownerSupport);\n}\n//# sourceMappingURL=setupSubscribe.function.js.map","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n//# sourceMappingURL=syncPriorPropFunction.function.js.map","import { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, _values, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\nexport function prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        console.log('updating into a tag', contextItem);\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n//# sourceMappingURL=tagValueUpdateHandler.function.js.map","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { prepareUpdateToComponent } from './tagValueUpdateHandler.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    console.log('goto tag', {\n        placeholder: contextItem.placeholder,\n        parent: contextItem.placeholder?.parentNode,\n        contextItem,\n        processInit: newValue.processInit,\n        newValue,\n    });\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\n//# sourceMappingURL=tryUpdateToTag.function.js.map","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n//# sourceMappingURL=updateExistingArray.function.js.map","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n//# sourceMappingURL=updateExistingObject.function.js.map","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n//# sourceMappingURL=updateToDiffValue.function.js.map","import { BasicTypes, deleteSimpleValue } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    console.log('old place holder - 0', {\n        simpleValueElm: contextItem.simpleValueElm,\n        placeholder: contextItem.placeholder,\n        equal: contextItem.simpleValueElm === contextItem.placeholder,\n        parentNode0: contextItem.placeholder?.parentNode,\n        parentNode1: contextItem.simpleValueElm?.parentNode,\n        newValue,\n    });\n    deleteSimpleValue(contextItem);\n    console.log('old place holder - 1', {\n        simpleValueElm: contextItem.simpleValueElm,\n        placeholder: contextItem.placeholder,\n        equal: contextItem.simpleValueElm === contextItem.placeholder,\n        parentNode0: contextItem.placeholder?.parentNode,\n        parentNode1: contextItem.simpleValueElm?.parentNode,\n        newValue,\n    });\n    setTimeout(() => {\n        console.log('old place holder - 2', {\n            simpleValueElm: contextItem.simpleValueElm,\n            placeholder: contextItem.placeholder,\n            equal: contextItem.simpleValueElm === contextItem.placeholder,\n            parentNode0: contextItem.placeholder?.parentNode,\n            parentNode1: contextItem.simpleValueElm?.parentNode,\n            newValue,\n        });\n    }, 100);\n    return 6; // 'changed-simple-value'\n}\n//# sourceMappingURL=checkSimpleValueChange.function.js.map","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n//# sourceMappingURL=getArrayTagJsVar.function.js.map","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, _values, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    contextItem.handler = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        delete: deleteSubContext,\n        checkValueChange: () => console.debug('weird innerHTML check'),\n    };\n}\n//# sourceMappingURL=getInnerHTML.function.js.map","import { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintRemover } from \"../render/paint.function.js\";\nimport { checkSimpleValueChange } from \"./checkSimpleValueChange.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        checkValueChange: checkSimpleValueChange,\n        delete: deleteSimpleValue,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n                console.log('insertBefore simple', { x, value, parentNode: x.parentNode });\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    delete contextItem.tagJsVar;\n    // is it being destroyed before it was even built?\n    if (contextItem.paint !== undefined) {\n        const paintIndex = paintCommands.findIndex(paint => paint === contextItem.paint);\n        paintCommands.splice(paintIndex, 1);\n        return;\n    }\n    paintCommands.push([paintRemover, [elm]]);\n}\n//# sourceMappingURL=getSimpleTagVar.function.js.map","export * from './subscribe.function.js';\nexport * from './getInnerHTML.function.js';\nexport * from './tag.function.js';\nexport { deleteSimpleValue } from './getSimpleTagVar.function.js';\nexport { checkSimpleValueChange } from './checkSimpleValueChange.function.js';\n//# sourceMappingURL=index.js.map","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            console.debug('weird to be here');\n            return -1;\n        },\n        Observable,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n//# sourceMappingURL=subscribe.function.js.map","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n//# sourceMappingURL=tag.function.js.map","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n//# sourceMappingURL=valueToTagJsVar.function.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { run } from './run.function'\n\nrun()"],"names":[],"sourceRoot":""}